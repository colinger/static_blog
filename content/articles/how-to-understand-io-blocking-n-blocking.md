Title: 如何理解IO阻塞
Date: 2015-08-21 17:26
Category: io
Tags: io
Slug: how-to-understand-io
Author: Colin

本文来自[知呼](http://www.zhihu.com/question/19732473)

> 一讲到网络编程的I/O模型，总会涉及到这几个概念。问了很多人，没几个能清晰地讲出他们之间的区别联系，甚至在网络上也有很多不同的观点，也不知是中国文字释义的博大精深，还是本来这几个概念就是绕人不倦。今天我也来给大家讲解一下我对这几个概念的理解。


既然网络上众说纷纭，不如找个权威参考一下，这个权威就是《UNIX网络编程：卷一》第六章——I/O复用。书中向我们提及了5种类UNIX下可用的I/O模型：

* 阻塞式I/O
* 非阻塞式I/O
* I/O复用（select，poll，epoll...）
* 信号驱动式I/O（SIGIO）
* 异步I/O（POSIX的aio_系列函数）

###阻塞式I/O模型
> 默认情况下，所有套接字都是阻塞的。怎么理解？先理解这么个流程，一个输入操作通常包括两个不同阶段：

	（1）等待数据准备好；
	（2）从内核向进程复制数据。
	
对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 好，下面我们以阻塞套接字的recvfrom的的调用图来说明阻塞

<img src="http://colinger.github.io/images/6_1.jpg" width = "800" height = "400" alt="" /><br/>
标红的这部分过程就是阻塞，直到阻塞结束recvfrom才能返回。

###非阻塞式I/O： 
以下这句话很重要：进程把一个套接字设置成非阻塞是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。看看非阻塞的套接字的recvfrom操作如何进行

<img src="http://colinger.github.io/images/6_2.jpg" width = "800" height = "400" alt="" /><br/>
可以看出recvfrom总是立即返回。

###I/O多路复用：
虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。如图
<img src="http://colinger.github.io/images/6_3.jpg" width = "800" height = "400" alt="" /><br/>

###信号驱动式I/O：
用的很少，就不做讲解了。直接上图
<img src="http://colinger.github.io/images/6_4.jpg" width = "800" height = "400" alt="" /><br/>
###异步I/O：
这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。如图：

<img src="http://colinger.github.io/images/6_5.jpg" width = "800" height = "400" alt="" /><br/>
注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们。

等等，大家一定要问了，同步这个概念你怎么没涉及啊？别急，您先看总结。 其实前四种I/O模型都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间），进程阻塞于recvfrom调用。相反，异步I/O模型在这两个阶段都要处理。

<img src="http://colinger.github.io/images/6_6.jpg" width = "800" height = "400" alt="" /><br/>
再看POSIX对这两个术语的定义：

* 同步I/O操作：导致请求进程阻塞，直到I/O操作完成；
* 异步I/O操作：不导致请求进程阻塞。

好，下面我用我的语言来总结一下阻塞，非阻塞，同步，异步

* 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；
* 同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。